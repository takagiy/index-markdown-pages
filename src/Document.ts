import { readFile, writeFile } from "node:fs/promises";
import type { Root, RootContent } from "mdast";
import { fromMarkdown as mdastFromString } from "mdast-util-from-markdown";
import { toString as mdastToString } from "mdast-util-to-string";

export class Document {
  protected constructor(
    public readonly path: string,
    protected content: string | null,
  ) {}

  static async open(path: string) {
    const content = await readFile(path, "utf-8");
    return new Document(path, content);
  }

  static MATCH_SPECIAL_CHARACTERS =
    /[\\\x60\*_\{\}\[\]\x3c\x3e\x23\(\)\x21\+\x2d\|]/g;

  static MARKER_BEGIN =
    "<!-- BEGIN generated by takagiy/index-markdown-pages -->";
  static MARKER_END = "<!-- END generated by takagiy/index-markdown-pages -->";

  static escape(text: string): string {
    return text.replaceAll(Document.MATCH_SPECIAL_CHARACTERS, (match) => {
      return `\\${match}`;
    });
  }

  static escapeLink(text: string): string {
    return text.replaceAll(Document.MATCH_SPECIAL_CHARACTERS, (match) => {
      return `%${match.charCodeAt(0).toString(16)}`;
    });
  }

  async save() {
    if (this.content === null) {
      return;
    }
    writeFile(this.path, this.content, "utf-8");
  }

  findHeading(depth: number, mdast: Root): RootContent | null {
    const headings = mdast.children.filter(
      (node) => node.type === "heading" && node.depth === depth,
    );
    if (headings.length === 1) {
      return headings[0] ?? null;
    }
    if (depth < 6) {
      return this.findHeading(depth + 1, mdast);
    }
    return null;
  }

  async title(): Promise<string | null> {
    const content = this.content ?? (await readFile(this.path, "utf-8"));
    const tree = mdastFromString(content);
    const heading = this.findHeading(1, tree);
    if (!heading) {
      return null;
    }
    return mdastToString(heading);
  }

  async clean() {
    const MARKER_BEGIN = Document.MARKER_BEGIN;
    const MARKER_END = Document.MARKER_END;

    if (this.content === null) {
      this.content = await readFile(this.path, "utf-8");
    }

    const doesMatch = this.content.match(
      new RegExp(`${MARKER_BEGIN}.*${MARKER_END}`, "s"),
    );

    if (doesMatch) {
      this.content = this.content.replace(
        new RegExp(`${MARKER_BEGIN}.*${MARKER_END}`, "s"),
        "",
      );
    }
  }

  async replaceOrAppend(appendContent: string) {
    const MARKER_BEGIN = Document.MARKER_BEGIN;
    const MARKER_END = Document.MARKER_END;

    if (this.content === null) {
      this.content = await readFile(this.path, "utf-8");
    }

    const append = appendContent.endsWith("\n")
      ? appendContent
      : `${appendContent}\n`;

    const doesMatch = this.content.match(
      new RegExp(`${MARKER_BEGIN}.*${MARKER_END}`, "s"),
    );

    if (doesMatch) {
      this.content = this.content.replace(
        new RegExp(`${MARKER_BEGIN}.*${MARKER_END}`, "s"),
        `${MARKER_BEGIN}\n${append}${MARKER_END}`,
      );
    } else if (this.content.endsWith("\n")) {
      this.content += `\n${MARKER_BEGIN}\n${append}${MARKER_END}\n`;
    } else {
      this.content += `\n\n${MARKER_BEGIN}\n${append}${MARKER_END}\n`;
    }
  }
}
